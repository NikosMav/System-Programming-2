# System Programming Assignment - File Monitoring and Processing

## Overview

As depicted in the diagram (not included here), the program consists of the manager, listener, and one or more workers. The central process is the manager, which creates the listener and workers. Communication between processes is achieved using pipes, named pipes, and signals. All I/O operations are performed using low-level I/O functions (open, close, write, read, etc.). The program is implemented in C/C++ and is intended for a Linux environment.

### Code and Header Files Directory

- manager.cpp: Contains the main() function that creates the listener child process. It creates the listener using fork() and calls the inotifywait process with arguments {closed_write, moved_to} to monitor the specified folder. The manager then creates the corresponding workers consulting the queue it has generated. If an available worker is found in the queue, the manager sends a SIGCONT signal and reuses the same worker, resuming its operation. It writes the names of the incoming files to the workers via named pipes and waits for a new file from the listener. When a worker terminates, the manager receives a SIGCHLD signal, identifies the stopped child, changes its availability (availability = true), and puts it back in the worker queue. Upon program exit initiated by the user with the SIGINT signal, the manager terminates the listener, workers, releases memory, and closes.
- worker.cpp: Represents the child process created by manager using fork() - execvp() and processes new files sent by the listener. File names are transferred to workers through named pipes following the convention that each pipe's path consists of “tmp/fifo” and ends with the worker's number. Each worker, after receiving the filename, performs the process as described in the assignment, identifies URLs using regex and maps, creates output files, and writes the results. It closes by raising SIGSTOP on itself and waits in a stopped state to be assigned a new file. In case of exit and reception of the SIGTERM signal from the manager, the worker releases memory and closes.
- aux.cpp: This file was created purely for auxiliary purposes and provides convenience and readability to the main program.
- queueInfo.cpp: Created to store information about the workers in the queue managed by the manager. Specifically, an information block {pid, availability, pipe name} is created for each worker.

### Assumptions

The main assumption of the program is that all output files generated by the program (.out files) go into the ./files_output/ folder.
Another assumption is that the folder to be monitored by the program should be located within the broader program directory. For convenience, a ./files/ folder is included in the deliverable where users can place files. Otherwise, creating a new folder within the main directory is a basic requirement of the program.

### Execution and Usage

The provided folder includes a makefile for compiling all executables. By running the following commands, the program is ready for use:

```bash
make clean && make
```

After compiling the files, the user must run the command:

```bash
  ./sniffer [-p path]
```

For the second argument, the user only needs to specify the name of the folder they want to monitor. Therefore, it is necessary for this folder to be located within the broader program directory. If the second argument is not given, the current directory is considered the monitored directory.
For example, the correct execution of the program is as follows:

```bash
./sniffer -p files
```

or simply

```bash
./sniffer
```

To execute the bash script, the user must run the command:

```bash
./finder.sh [path] [tld1, tld2, … tldn]
```

In the [path] argument, the user specifies the directory containing all the .out files, and in the subsequent arguments, one or more TLDs that they want to search for.
For example, the correct execution of the script is as follows:

```bash
./finder.sh ./files_output/ gr com gov
```
## License

This project is for educational use only and is part of the coursework for _Κ24 System Programming_ at _DiT, NKUA_.
